!function e(t,n,i){function o(r,s){if(!n[r]){if(!t[r]){var l="function"==typeof require&&require;if(!s&&l)return l(r,!0);if(a)return a(r,!0);var u=new Error("Cannot find module '"+r+"'");throw u.code="MODULE_NOT_FOUND",u}var f=n[r]={exports:{}};t[r][0].call(f.exports,function(e){var n=t[r][1][e];return o(n||e)},f,f.exports,e,t,n,i)}return n[r].exports}for(var a="function"==typeof require&&require,r=0;r<i.length;r++)o(i[r]);return o}({1:[function(e,t,n){"use strict";if(function t(n,i,o){function a(s,l){if(!i[s]){if(!n[s]){var u="function"==typeof e&&e;if(!l&&u)return u(s,!0);if(r)return r(s,!0);var f=new Error("Cannot find module '"+s+"'");throw f.code="MODULE_NOT_FOUND",f}var h=i[s]={exports:{}};n[s][0].call(h.exports,function(e){return a(n[s][1][e]||e)},h,h.exports,t,n,i,o)}return i[s].exports}for(var r="function"==typeof e&&e,s=0;s<o.length;s++)a(o[s]);return a}({1:[function(e,t,n){t.exports=function(e){"string"==typeof e&&(e=[e]);for(var t=[].slice.call(arguments,1),n=[],i=0;i<e.length-1;i++)n.push(e[i],t[i]||"");return n.push(e[i]),n.join("")}},{}],2:[function(e,t,n){Object.defineProperty(n,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),o=e("glslify"),a=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"mesh",n=arguments[1],i=this,a=arguments[2];arguments[3],function(t,n){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this);var r=o(["#define GLSLIFY 1\nuniform sampler2D map;\nuniform float opacity;\n\nuniform float uvdy;\nuniform float uvdx;\n\nvarying float visibility;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPos;\n\nvoid main() {\n\n    if ( visibility < 0.75 ) discard;\n\n    vec4 color = texture2D( map, vUv + vec2(uvdx, uvdy));\n    color.w = opacity;\n\n    gl_FragColor = color;\n    \n}"]),s=o(["#define GLSLIFY 1\nuniform float mindepth;\nuniform float maxdepth;\n\nuniform float width;\nuniform float height;\n\nuniform bool isPoints;\nuniform float pointSize;\n\nuniform float time;\n\nvarying vec3 vNormal;\nvarying vec3 vPos;\n\n//TODO: make uniforms\nconst float fx = 1.11087;\nconst float fy = 0.832305;\n\nuniform sampler2D map;\n\n//Making z global\nfloat z;\n\nvarying float visibility;\nvarying vec2 vUv;\n\nvec3 rgb2hsl( vec3 color ) {\n    float h = 0.0;\n    float s = 0.0;\n    float l = 0.0;\n    float r = color.r;\n    float g = color.g;\n    float b = color.b;\n    float cMin = min( r, min( g, b ) );\n    float cMax = max( r, max( g, b ) );\n    l =  ( cMax + cMin ) / 2.0;\n    if ( cMax > cMin ) {\n        float cDelta = cMax - cMin;\n        // saturation\n        if ( l < 0.5 ) {\n            s = cDelta / ( cMax + cMin );\n        } else {\n            s = cDelta / ( 2.0 - ( cMax + cMin ) );\n        }\n\n        // hue\n        if ( r == cMax ) {\n            h = ( g - b ) / cDelta;\n        } else if ( g == cMax ) {\n            h = 2.0 + ( b - r ) / cDelta;\n        } else {\n            h = 4.0 + ( r - g ) / cDelta;\n        }\n\n        if ( h < 0.0) {\n            h += 6.0;\n        }\n        h = h / 6.0;\n\n    }\n    return vec3( h, s, l );\n}\n\nvec3 xyz( float x, float y, float depth ) {\n    z = depth * ( maxdepth - mindepth ) + mindepth;\n    return vec3( ( x / height  ) * z * fx, ( y / (width * 2.0)  ) * z * fy, - z );\n}\n\nvoid main() {\n\n    vUv = vec2( ( position.x + 512.0 ) / 1024.0 , ( position.y + 512.0  ) / 1024.0 );\n\n    vUv.y = vUv.y * 0.5;// + 0.5;\n\n    vPos = (modelMatrix * vec4(position, 1.0 )).xyz;\n    vNormal = normalMatrix * normal;\n\n    vec3 hsl = rgb2hsl( texture2D( map, vUv ).xyz );\n    vec4 pos = vec4( xyz( position.x, position.y, hsl.x ), 1.0 );\n    pos.z += 2600.0;\n\n    visibility = hsl.z * 2.1;\n\n    if(isPoints){\n        gl_PointSize = pointSize;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * pos;\n}"]);switch(this.video=document.createElement("video"),this.video.crossOrigin="anonymous",this.video.setAttribute("crossorigin","anonymous"),this.video.src=a,this.video.autoplay=!1,this.video.loop=!1,this.videoTexture=new THREE.VideoTexture(this.video),this.videoTexture.minFilter=THREE.NearestFilter,this.videoTexture.magFilter=THREE.LinearFilter,this.videoTexture.format=THREE.RGBFormat,this.videoTexture.generateMipmaps=!1,this.manager=new THREE.LoadingManager,this.props,e.geo||e.buildGeomtery(),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:this.videoTexture},time:{type:"f",value:0},mindepth:{type:"f",value:0},maxdepth:{type:"f",value:0},uvdy:{type:"f",value:.5},uvdx:{type:"f",value:0},width:{type:"f",value:0},height:{type:"f",value:0},opacity:{type:"f",value:1},isPoints:{type:"b",value:!1},pointSize:{type:"f",value:3}},vertexShader:s,fragmentShader:r,transparent:!0}),this.material.side=THREE.DoubleSide,t){case"wire":this.material.wireframe=!0,this.mesh=new THREE.Mesh(e.geo,this.material);break;case"points":this.material.uniforms.isPoints.value=!0,this.mesh=new THREE.Points(e.geo,this.material);break;default:this.mesh=new THREE.Mesh(e.geo,this.material)}this.jsonLoader=new THREE.FileLoader(this.manager),this.jsonLoader.setResponseType("json"),this.jsonLoader.load(n,function(e){i.props=e,i.material.uniforms.width.value=i.props.textureWidth,i.material.uniforms.height.value=i.props.textureHeight,i.material.uniforms.mindepth.value=i.props.nearClip,i.material.uniforms.maxdepth.value=i.props.farClip}),this.mesh.depthkit=this;var l=new THREE.SphereGeometry(300,32,32),u=new THREE.MeshBasicMaterial({color:16776960,wireframe:!0});return this.colider=new THREE.Mesh(l,u),this.colider.scale.set(5,2.5,2.5),this.colider.visible=!1,this.mesh.add(this.colider),this.mesh.name="depthkit",this.mesh}return i(e,[{key:"setPointSize",value:function(e){this.material.uniforms.isPoints.value?this.material.uniforms.pointSize.value=e:console.warn("Can not set point size because the current character is not set to render points")}},{key:"setOpacity",value:function(e){this.material.uniforms.opacity.value=e}},{key:"setLineWidth",value:function(e){this.material.wireframe?this.material.wireframeLinewidth=e:console.warn("Can not set the line width because the current character is not set to render wireframe")}},{key:"play",value:function(){this.video.isPlaying?console.warn("Can not play because the character is already playing"):this.video.play()}},{key:"stop",value:function(){this.video.currentTime=0,this.video.pause()}},{key:"pause",value:function(){this.video.pause()}},{key:"setLoop",value:function(e){this.video.loop=e}},{key:"setVolume",value:function(e){this.video.volume=e}},{key:"update",value:function(e){this.material.uniforms.time.value=e}},{key:"dispose",value:function(){}}],[{key:"buildGeomtery",value:function(){e.geo=new THREE.Geometry;for(var t=0;t<256;t++)for(var n=0;n<256;n++)e.geo.vertices.push(new THREE.Vector3(5*n-640,480-5*t,0));for(var i=0;i<255;i++)for(var o=0;o<255;o++)e.geo.faces.push(new THREE.Face3(o+256*i,o+256*(i+1),o+1+256*i)),e.geo.faces.push(new THREE.Face3(o+1+256*i,o+256*(i+1),o+1+256*(i+1)))}}]),e}();n.default=a},{glslify:1}],3:[function(e,t,n){var i,o=(i=e("./depthkit"))&&i.__esModule?i:{default:i};window.DepthKit=o.default},{"./depthkit":2}]},{},[3]),"undefined"==typeof AFRAME)throw new Error("Component attempted to register before AFRAME was available.");AFRAME.registerComponent("depthkit",{schema:{type:{type:"string",default:"mesh"},videoPath:{type:"string"},metaPath:{type:"string"},loop:{type:"boolean",default:!0},autoplay:{type:"boolean",default:!0}},multiple:!0,init:function(){var e=new DepthKit(this.data.type,this.data.metaPath,this.data.videoPath);e.depthkit.setLoop(this.data.loop),e.rotation.z=THREE.Math.degToRad(90),this.data.autoplay&&e.depthkit.play(),this.el.setObject3D("mesh",e),this.el.object3D.scale.multiplyScalar(.001),this.el.object3D.position.z=-2,this.el.object3D.position.y=1},update:function(e){},remove:function(){},pause:function(){},play:function(){}})},{}]},{},[1]);
